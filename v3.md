### V3 Hashlock Transfers – User Guide

This guide explains how to send and receive Unchained V3 transfers (hashlock + stealth) with a focus on a simple, reliable workflow. V3 spends are signatureless and post‑quantum safe. They use Kyber KEM, a BLAKE3 hashlock, and a Merkle UTXO proof. The sender cannot spend the funds; only the receiver can derive the secret needed to unlock the output.

### Key concepts (plain English)
- Stealth address: A single string the receiver shares (includes their Dilithium and Kyber public keys). The sender needs only this to address payments.

- Batch commitment token: A single base64 string the receiver provides per payment. It contains the receiver’s cryptographic commitments for all coins the sender will use in that payment. One token, many inputs.

- Auto vs offline: If both wallets are online, the sender can request commitments automatically over P2P. If not, the receiver can send one batch token out‑of‑band (chat, email, QR).

### Prerequisites
- Both sides have a running node and unlocked wallet.
- Receiver shares their stealth address with the sender (once is enough):
  - Run the node and print your stealth address:
  ```bash
  unchained StealthAddress
  ```
  - Copy the printed base64 string and share it with the sender.

### Sending a V3 transfer (sender)
1) Start the interactive send flow:
   ```bash
   unchained Send --stealth
   ```
2) Paste the receiver’s stealth address when prompted.
3) Enter the amount to send.
4) Choose commitment exchange method when prompted:
   - Automatic (recommended if receiver is online): select Yes. The wallet will request a single batch commitment from the receiver over P2P and proceed automatically.
   - Offline (fallback): select No. Paste a single batch commitment token provided by the receiver (one base64 string covers all selected inputs).

Notes
- The wallet selects inputs automatically. If the offline token does not cover the chosen inputs, you will see a clear error:
  - “missing entries for coin_id=…” → The token does not include one of your inputs. Ask the receiver for a new token (or try again later to let the wallet re‑select inputs).
  - “amount mismatch for coin_id=…” → The amount bound in the token does not match your input amount. Ask the receiver to regenerate the token for this payment.

### Receiving V3 transfers (receiver)
- Share your stealth address with payers. If you are online, the wallet can accept commitment requests over P2P and respond with a single signed batch commitment.
- If you are offline or prefer manual flow, generate one batch commitment per payment and send it to the payer as a single base64 token (the token binds to their selected input coin_ids and amounts). The payer pastes the token once and completes the send.
- After the send is broadcast, your wallet will detect incoming spends and update your balance automatically when the epoch finalizes.

### Troubleshooting
- Automatic exchange times out: The receiver may be offline. Use the offline fallback path by pasting a single batch token.
- “missing entries for coin_id=…”: The batch token does not include all of the sender’s input coin_ids. Regenerate a token for that payment or ask the sender to retry (their wallet will re‑select inputs and ask again).
- “amount mismatch for coin_id=…”: The token was generated with a different amount for that coin_id. Regenerate the token.
- Invalid token / signature: Ensure the receiver created the token from their wallet and didn’t copy it partially. Re‑share the token.

### Best practices
- Prefer automatic exchange when both sides are online. It’s one click for both users, no copy‑paste.
- Use offline batch tokens only when necessary; always send one token per payment, never one per coin.
- Keep your node running to auto‑detect incoming funds and serve commitment requests quickly.

### What happens under the hood (short)
- The sender proves the coin exists (Merkle UTXO proof) and reveals a preimage for the current hashlock.
- The receiver’s batch commitment ensures only the receiver can derive the next secret; the sender never learns it.
- A nullifier prevents double‑spends.

That’s it — V3 makes sending as simple as “paste address + amount”, with automatic exchange by default and a single offline token when needed.


